\documentclass[a4paper,french,bookmarks]{book}

\usepackage{booktabs}
\usepackage{minitoc}
\usepackage{./Structure/4PE18TEXTB}
\usepackage{proof}
\usepackage{pdfpages}
\usepackage{subfiles}

\makeatletter
\renewcommand*\l@section{\@dottedtocline{1}{1.8em}{3.5em}}
\renewcommand*\l@subsection{\@dottedtocline{2}{5.3em}{3.5em}}
\makeatother

\newboxans
\renewcommand{\thechapter}{\Roman{chapter}}
\renewcommand{\thesubsection}{\thesection.\Alph{subsection}}
\renewcommand{\thesubsubsection}{\thesubsection.\alph{subsubsection}}
\mtcsettitle{minitoc}{}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3}
\setcounter{minitocdepth}{3}

\newcommand{\Atom}{\mathop{\bcA_\text{tom}}\nolimits}
\newcommand{\langOcaml}{\texttt{\color{ocamlColor!20!black}OCaml}}
\newcommand{\langC}{\texttt{\color{ocamlColor!20!black}C}}

\DeclareMathOperator{\Reg}{Reg}
\DeclareDocumentCommand\FO{g}{\funlv{FO}{#1}}
\DeclareDocumentCommand\FV{g}{\funlv{FV}{#1}}
\DeclareDocumentCommand\BV{g}{\funlv{BV}{#1}}
\DeclareDocumentCommand\FP{g}{\funlv{FP}{#1}}
\DeclareDocumentCommand\th{g}{\funlv{th}{#1}}
\DeclareDocumentCommand\First{g}{\funlv{First}{#1}}
\DeclareDocumentCommand\Last{g}{\funlv{Last}{#1}}
\DeclareDocumentCommand\Fact{g}{\funlv{Fact}{#1}}
\DeclareDocumentCommand\NFact{g}{\funlv{NFact}{#1}}
\DeclareDocumentCommand\Loc{g}{\funlv{Loc}{#1}}
\DeclareDocumentCommand\CFL{g}{\funlv{CFL}{#1}}
\DeclareDocumentCommand\Pref{g}{\funlv{Pref}{#1}}
\DeclareDocumentCommand\Suff{g}{\funlv{Suff}{#1}}

\newcommand{\cP}{\bbP}
\newcommand{\cNP}{\bbN\bbP}

\newcommand{\chaptertoc}[0]{
    \begin{tcolorbox}[
        enhanced,
        frame hidden,
        sharp corners,
        detach title,
        spread outwards     = 5pt,
        halign              = center,
        valign              = center,
        borderline west     = {3pt}{0pt}{main20!50!main2!95!gray!90},
        coltitle            = main20!50!main2!95!gray!90, 
        interior style      = {
            left color      = main1white2!65!gray!11,
            middle color    = main1white2!50!gray!10,
            right color     = main1white2!35!gray!9
        },
        arc                 = 0 cm,
        title               = SOMMAIRE,
        boxrule             = 0pt,
        fonttitle           = \bfseries\sffamily,
        overlay             = {
            \node[rotate=90, minimum width=1cm, anchor=south,yshift=-0.8cm]
            at (frame.west) {\tcbtitle};
        }
    ]
        \begin{minipage}{0.83\linewidth}
            \sffamily
            \minitoc
        \end{minipage}
    \end{tcolorbox}
}

\begin{document}
    
    %==============================
    % METADONNEES
    %==============================
    
    \title{Cours d'Informatique de MPI* (2022-2023)}
    \author{SIAHAAN--GENSOLLEN Rémy}
    \date{\today}
    \hypersetup{
        pdftitle={Cours d'Informatique de MPI* (2022-2023)},
        pdfauthor={SIAHAAN--GENSOLLEN Rémy},
        pdflang={fr-FR},
        pdfsubject={MPI*, Cours d'Informatique},
        pdfkeywords={MPI*, Cours d'Informatique, 2022-2023}
        pdfstartview=
    }
    
    %==============================
    % MISE EN PAGE
    %==============================
    
    \titleformat{\chapter}[display]{\normalfont\huge\bfseries}{}{0pt}{
        \begin{tcolorbox}[
            enhanced,
            frame hidden,
            sharp corners,
            spread sidewards    = 5pt,
            halign              = center,
            valign              = center,
            interior style      = {color=main1!20},
            arc                 = 0 cm,
            fontupper           = \color{black}\sffamily\bfseries\huge,
            fonttitle           = \normalfont\color{white}\sffamily\small,
            top                 = 1cm, 
            bottom              = 0.7cm,
            title               = Chapitre \thechapter,
            attach boxed title to bottom center = {
                yshift=\tcboxedtitleheight/2,
            },
            boxed title style = {
                frame code={
                \path[left color=main2!95!gray!90,
                right color=main1!95!gray!90] 
                    ([xshift=-10mm]frame.north west) -- 
                    ([xshift=10mm]frame.north east) -- 
                    ([xshift=10mm]frame.south east) -- 
                    ([xshift=-10mm]frame.south west) -- 
                    cycle;
                },
                interior engine=empty
            }
        ]
            #1
        \end{tcolorbox}%
    }
    \titlespacing*{\chapter}{0pt}{-120pt}{-15pt}
    \titleformat{name=\chapter,numberless}[display]{\normalfont\huge\bfseries}
    {}{0pt}{
        \begin{tcolorbox}[
            enhanced,
            frame hidden,
            sharp corners,
            spread sidewards    = 5pt,
            halign              = center,
            valign              = center,
            interior style      = {color=main1!20},
            arc                 = 0 cm,
            outer arc           = 0pt,
            leftrule            = 0pt,
            rightrule           = 0pt,
            fontupper           = \color{black}\sffamily\bfseries\huge,
            enlarge left by     = -1in-\hoffset-\oddsidemargin, 
            enlarge right by    = -\paperwidth+1in+\hoffset +
            \oddsidemargin+\textwidth,
            width               = \paperwidth, 
            left                = 1in+\hoffset+\oddsidemargin, 
            right               = \paperwidth-1in-\hoffset -
            \oddsidemargin-\textwidth,
            top                 = 1cm, 
            bottom              = 1cm
        ]
            #1
        \end{tcolorbox}%
    }
    \titlespacing*{name=\chapter,numberless}{0pt}{-115pt}{0pt}
    
    %==============================
    % PREMIERE DE COUVERTURE
    %==============================

    \includepdf[pages={1},scale=1.15,offset=0mm -18mm]{CICover.pdf}
    
    %==============================
    % PAGE VIDE
    %==============================
    
    \pagestyle{empty}
    
    %==============================
    % PAGE DE COUVERTURE INTERNE
    %==============================
    
    \begin{titlepage}
	    \begin{center}
	        {\scshape SIAHAAN-{}-GENSOLLEN Rémy\par}
	        {\footnotesize avec l'aide de \textsc{DRISSI Rayan} et \textsc{SALOUM Gwendal}\par}
	        \vspace{2.5cm}
	        {\huge\sffamily Cours d'\par}
	        \vspace{0.1cm}
	        {\Huge\bfseries\sffamily INFORMATIQUE\par}
	        \vspace{1cm}
	        {\Large\emph{donné pendant mon année de \guill{spé'} en \emph{$\textsf{MPI}^\star$} à
	        Janson-de-Sailly}\\[2pt]\texttt{2022-2023}\par}
	        \vfill
	        {\large\EBGaramond Compilé le \today\par}
        \end{center}
    \end{titlepage}
    
    %==============================
    % PAGE VIDE
    %==============================
    
    \pagestyle{empty}\text{}\newpage
    
    %==============================
    % STYLE DES EN-TÊTES ET PIEDS DE PAGES
    %==============================
    
    \renewcommand\chaptermark[1]{\markboth{#1}{}}
    
    \fancypagestyle{intro}{
        \fancyhf{}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}\fancyfoot[RO,LE]{\GillSansMTMedium\color{white5}\thepage\;/\;\pageref{LastPage}}
        \fancyhead[LE]{\GillSansMTMedium\color{white5}\bfseries COURS D'INFORMATIQUE}
        \fancyhead[RE]{\GillSansMTMedium\color{white5}Avant-propos}
        \fancyhead[LO]{\GillSansMTMedium\color{white5}\rightmark}
        \fancyhead[RO]{\GillSansMTMedium\color{white5}$\textbf{MPI}^\star$ 2022-2023 \quad Janson-de-Sailly}
    }
    
    \fancypagestyle{toc}{
        \fancyhf{}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}\fancyfoot[RO,LE]{\GillSansMTMedium\color{white5}\thepage\;/\;\pageref{LastPage}}
        \fancyhead[LE]{\GillSansMTMedium\color{white5}\bfseries COURS D'INFORMATIQUE}
        \fancyhead[RE]{\GillSansMTMedium\color{white5}Table des matières}
        \fancyhead[LO]{\GillSansMTMedium\color{white5}\rightmark}
        \fancyhead[RO]{\GillSansMTMedium\color{white5}$\textbf{MPI}^\star$ 2022-2023 \quad Janson-de-Sailly}
    }
    
    \fancypagestyle{plain}{
        \fancyhf{}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}\fancyfoot[RO,LE]{\GillSansMTMedium\color{white5}\thepage\;/\;\pageref{LastPage}}
        \fancyhead[LE]{\GillSansMTMedium\color{white5}\bfseries COURS D'INFORMATIQUE}
        \fancyhead[RE]{\GillSansMTMedium\color{white5}Chapitre \thechapter : \nouppercase{\leftmark}}
        \fancyhead[LO]{\GillSansMTMedium\color{white5}\nouppercase{\rightmark}}
        \fancyhead[RO]{\GillSansMTMedium\color{white5}$\textbf{MPI}^\star$ 2022-2023 \quad Janson-de-Sailly}
    }
    
    %==============================
    % PREFACE 
    %==============================
    
    \chapter*{Avant-propos}
    \thispagestyle{intro}
    \addcontentsline{toc}{chapter}{Avant-propos}
    
    \text{\Large\EBGaramond\itshape À tout lecteur potentiel, quelques remarques préalables ...}\newline\newline\newline
    
    \begin{center}
        \begin{minipage}{0.85\linewidth}
            \large \qquad Comme son nom peut l'indiquer, cet ouvrage est la compilation de notes de cours d'informatique dispensés par M. Antony
            \textsc{Lick} durant mon année de \guill{spé'} en \textsf{MPI*} à \emph{Janson-de-Sailly} (année académique 2022-2023). De ce fait,
            certaines parties risquent d'être elliptiques, lacunaires, voire inexistantes, alors qu'elles seraient vitale à la compréhension du
            cours. Elles pourraient de plus être erronées, ou rédigées maladroitement, et donc induire en erreur. Ainsi, je conseillerai à tout
            lecteur potentiel de faire preuve de prudence lors du parcours de ce texte, et à ne pas hésiter à en vérifier le contenu par lui-même
            au moindre doute.\newline
            
            J'essaierai le plus possible de compléter, détailler et enrichir le contenu de ce livre au cours de l'année, que ce soit à l'aide de
            mes cours de première année, d'autres ouvrages, ou de recherches en général. Cette tâche étant cependant particulièrement chronophage,
            et puisque j'en mène en parallèle une similaire pour les enseignements de mathématiques et de physique, elle sera très rarement mené
            jusqu'au bout. Pour différencier mes ajouts personnels des notions hors programmes \emph{- notées (HP) -} abordées en cours par mon
            professeur, ceux-ci seront notés (HPP).\newline
            
            Par ailleurs, je suis loin d'avoir l'expérience et les compétences pédagogiques nécessaires à la création et l'édition d'un cours. Bien
            que je me sois dûment pour en rendre l'apparence le plus digeste possible (la mise en page et la composition graphique en général étant
            de ma conception personnelle), en prenant en compte les retours de mes camarades, il est probable que certains passages soient
            désagréables à lecture, trop \guill{lourds} ou trop peu clairs, que le style soit, au fil des pages, trop changeant, \etc
            \dots.\newline
    
            Si malgré les remarques précédentes, ce cours peut avoir une quelconque utilité à ceux qui s'y aventureraient, j'en serai amplement
            satisfait. Je remercie mes camarades et amis pour leurs nombreux retours constructifs et leur aide pour compléter le cours ; merci
            particulièrement à Gwendal et Rayan qui m'ont à chaque cours aidé à le noter en \LaTeX. \newline\newline\newline\text{}
        \end{minipage}
    \end{center}
    
    \hfill{\textsc{SIAHAAN-{}-GENSOLLEN Rémy}}
    
    \pagestyle{intro}
    
    %==============================
    % TABLE DES MATIERES
    %==============================

    %\newpage
    \dominitoc\nomtcrule 
    {\sffamily\tableofcontents}\mtcaddchapter\pagestyle{toc}
    
    %\cleardoublepage
    
    %==============================
    % COURS
    %==============================
    
    \pagestyle{plain}
    
    \chapter{Logique et systèmes de preuve}
    
    %\subfile{chapitre1}
    
    \chapter{Langages formels et théorie des automates}
    
    %\subfile{chapitre2}
    
    \chapter{Calculabilité et complexité}
    
    L'an dernier, l'on avait démontré deux résultats importants : le premier était l'indécidabilité du problème de l'arrêt, c'est-à-dire qu'il n'existe pas d'algorithme prenant en entrée le code source d'un programme $P$ et un argument $x$ de $P$ et renvoyant si $P$ termine sur $x$ ; le deuxième était l'inexistence d'un algorithme de tri par comparaisons dont la complexité dans le pire des cas serait meilleure que $\O{}{n\log n}$.\medskip
    
    Dans les deux cas, ces résultats resteront vrais dans le futur, peu importe les progrès technologiques qui seront faits sur les ordinateurs et dans les sciences en général. En effet, durant les démonstrations, jamais les capacités actuelles des ordinateurs n'ont été utilisées, le raisonnement ne se basant que sur la difficulté intrinsèque que rencontre un algorithme pour résoudre un problème. Historiquement, les ordinateurs n'existaient d'ailleurs même pas lors de la démonstration de l'indécidabilité du problème de l'arrêt.\medskip
    
    Le but de ce chapitre est de généraliser ces deux notions : d'une part introduire et étudier la notion de \emph{calculabilité} (ou de \emph{décidabilité}), qui caractérise les problèmes qu'il est possible (ou au contraire impossible) de résoudre à l'aide d'un algorithme (ou de manière équivalente, reconnaissables par une machine de \textsc{Turing}) ; d'autres part, pour les problèmes \emph{décidables}, de les découper en plusieurs \emph{classes de complexité}, regroupant les problèmes de même difficulté, \ie les problèmes tels que les meilleurs algorithmes les résolvants sont de complexité similaires.\medskip
    
    En particulier, nous nous pencherons sur les deux classes de complexité les plus célèbres 
    : $\cP$ \emph{(pour \textsf{\textbf{P}olynomial})} l'ensemble des problèmes qui peuvent être résolus par une machine de \textsc{Turing} \emph{déterministe} en temps polynomial, et $\cNP$ \emph{(pour \textsf{\textbf{N}on déterministe \textbf{P}olynomial)}} l'ensemble des problèmes qui peuvent être résolus par une machine de \textsc{Turing} \emph{non déterministe} en temps polynomial.\medskip 

    Tout comme on l'avons vu pour les automates finis, toute machine de \textsc{Turing} non déterministe peut être transformée en une machine de \textsc{Turing} déterministe, mais cette transformation va \textit{\large\EBGaramond a priori} augmenter le temps d'exécution de la machine de \textsc{Turing} de manière exponentielle. Ainsi, \textit{\large\EBGaramond a priori}, on a $\cP \subseteq \cNP$ (car une machine de \textsc{Turing} déterministe est une cas particulier de machine de \textsc{Turing} non déterministe), mais on sait pas si $\cNP \subseteq \cP$.\bigskip
    
    \chaptertoc
    
    La notion de \emph{machine de \textsc{Turing}} n'étant pas au programme, on étudiera les notions de calculabilité et de complexité en raisonnant sur des algorithmes écrits en \langOcaml{} et en \langC. Ceci revient au même, car l'\langOcaml{} et le \langC sont \textsc{Turing}-complets, c'est-à-dire que l'ensemble des fonctions qu'on peut écrire dans ces langages est en bijection avec l'ensemble des machines de \textsc{Turing} (c'est en fait le cas de n'importe quel langage ayant des variables de type \texttt{int} et des boucles \texttt{while}, c'est donc notamment le cas de Minecraft\texttrademark, des briques Lego\texttrademark, \dots).\medskip
    
    Les entrées et sorties du programme peuvent \textit{\large\EBGaramond a priori} être de n'importe quel type de langage utilisé.
    Pour les entrées, il sera souvent plus pratique d'utiliser le type \texttt{string} (chaîne de caractères), car il permet de représenter n'importe quel type manipulable par un ordinateur.
    
    
    \begin{definition}{Sérialisation}{}
        \begin{enumerate}
            \itast La \hg{conversion} d'une \hg{valeur arbitraire} en une \hg{chaîne de caractères} est appelée opération de \hg{sérialisation}. 
            
            \itast Inversement, le \hg{décodage} d'une \hg{chaîne de caractères} en un \hg{type donné} est appelé opération de  \hg{désérialisation}.
        \end{enumerate}
    \end{definition}
    
    Ces deux opérations sont très utilisées en informatique, notamment lorsque deux programmes doivent communiquer des données entre eux, ou qu'un programme doit sauvegarder des données dans un fichier pour une utilisation future.
    
    \begin{example}{}{}
        En \langOcaml, le module \camlline{Marshal} permet d'éffectuer de telles opérations:
        
        \begin{enumerate}
            \itt \camlline{Marshal.to_string : 'a -> extern_flags list -> string} où l'argument de type \camlline{extern_flags list} une liste d'options, notamment la liste vide \camlline{[]} si aucune options particulière n'est à utiliser.
                
            \itt \camlline{Marshal.of_string : string -> int -> a'} où l'argument de type \camlline{int} est la position initiale dans la chaîne, en pratique \camlline{0}.
        \end{enumerate}
        
    \end{example}
    
    \textbf{\sffamily Attention :} \langOcaml{} ne peut pas vérifier qu'il n'y a pas de problème de type concernant la valeur renvoyée par \camlline{Marshal.of_string}. Pour qu'une chaîne de caractères soit proprement décodée par ce moyen il faut qu'elle ait été obtenue par la fonction \camlline{Marshal.to_string} de la même version d'\langOcaml.
    
    \begin{example}{}{}
        D'autre formats, comme \hg{\texttt{XML}} ou \hg{\texttt{JSON}} permettent également de représenter des données par du texte. leur avantage est que la chaîne obtenue est lisible par un être humain, l'inconvénient étant donc que ce format prend plus de place en mémoire. 
    \end{example}
    
    \section{Décidabilité}
    
    \subsection{Problème de décision}
    
    \begin{definition}{Problème algorithmique}
        On appelle \hg{problème algorithmique} la spécification des données suivantes :
        %
        \begin{enumerate}
            \itast un ensemble d'entrées admissibles 
            
            \itast Une description des résultats attendu en fonction de l'entrée
        \end{enumerate}
    \end{definition}
    
    On donne ci-dessous quelques exemples de problèmes algorithmiques :
    %
    \begin{example}{}{}
        \begin{enumerate}
            \itt\hg{Entrée :} une liste d'entiers.
            
                \hg{Effet :} modifier la liste par effets de bords, pour qu'elle
                contienne les mêmes éléments qu'au début, mais dans l'ordre croissant.
                
            \itt\hg{Entrée :} un graphe pondéré $G$, deux sommets $s$ et $t$.
            
                \hg{Effet :} donner le plus court chemin de $s$ à $t$ dans $G$.
        \end{enumerate}
    \end{example}
    
    \begin{definition}{Fonctions mathématiques, algorithmes}{}
        Selon le contexte, le mot \guill{fonction} couvre au moins deux notions différentes :
        %
        \begin{enumerate}
            \itt Soient deux ensembles $E$ et $F$. On appelle fonction mathématique $f: E \to F$  est une relation binaire $\bcR \subset E\times F$ entre un ensemble $E$ d'antécédents et $F$ d'images, tels que tout élément de $F$ est en relation avec au plus un élément de $E$. Dans ce cas, on ne décrit pas nécessairement la manière dont chacune des images des antécédents peut être calculée. On parle de définition extentionelle.
            
            \itt Dans un programme informatique, une fonction est un fragment de code décrivant les opérations qui permettent de produire un résultat à partir d'une entrée. Dans ce cas, pour éviter les ambiguïtés, on parlera plutôt d'algorithme. Un algorithme est alors également une relation binaire entre des entrées et des sorties (et peut donc être vu comme une fonction mathématique), mais la différence est que la manière de calculer la sortie est précisée par son code source. On parle de définition intensionelle.
        \end{enumerate}
    \end{definition}
    
    Ainsi, à tout algorithme on peut associer une fonction mathématique, liant les entrées du programme aux sorties qu'il produit, et la fonction mathématique réalisée par l'algorithme est appelée la sémantique de l'algorithme. En revanche, une fonction mathématique peut ne pas admettre une réalisation par un programme.
    
    \begin{definition}{Fonction calculable}{}
        Une fonction mathématique totale $f: E \o S$ est dite \hg{calculable} s'il existe un algorithme $A$ tel que pour toute entre $e \in E$, l'algorithme $A$ appliqué à $e$ produit le résultat $f\p{e}$ en un temps fini.
    \end{definition}
    
    \begin{theorem}{}{}
        Il existe une infinité non dénombrable de fonctions non calculables.
    \end{theorem}
    
    \begin{nproof}
        Considérons $\bdN^\bdB$ l'ensemble des fonctions de $\bdN$ dans $\bdB$. D'après le théorème de \textsc{Cantor}, $\bdN^\bdB$ est infini indénombrable (car en bijection avec $\bcP\p{\bdN}$). Or, l'ensemble des algorithmes est dénombrable (car chaque programme est défini par son code source, qui est une chaîne de caractère finie). Il existe donc bien une infinité (non dénombrable) de fonctions mathématiques non calculables.
    \end{nproof}
    
    La preuve du théorème de \textsc{Cantor} que nous venons d'utiliser est en réalité très instructive : elle utilise ce qu'on appelle un argument diagonal, qui est un moyen de construire un objet menant à un paradoxe, et de conclure par un raisonnement par l'absurde.
    
    \begin{theorem}{Théorème de Cantor}
        Il n'existe pas de bijection de $E$ dans $\bcP(E)$.
    \end{theorem}
    
    \begin{nproof}
        En fait, il existe bien des injections (comme $x \mapsto \ens{x}$) mais pas de surjection. Soit $f$ une fonction $f : E \mapsto \bcP\p{E}$. Considérons l'ensemble :
        %
        \[ D = \ens{x \in E \enstq x \not\in f\p{x}}\]
        %
         Par l'absurde, supposons $f$ surjective. Puisque $D \subset \bcP\p{E}$, et $f$ est surjective, il existe $y \in E$ tel que $D = f\p{y}$. Dès lors, si $y \in D$, alors $y \not\in f\p{y} = D$, ce qui est absurde. Inversement, si $y \not\in D$, alors $y \not\in f\p{y}$ donc $y \in D$, ce qui est absurde.
         
         Donc un tel $y$ ne peut pas exister, et ainsi $f$ n'est pas surjective.
    \end{nproof}
    
    
    \begin{definition}{Problème de décision}{}
        Un problème de décision sur un domaine d'entrée $E$ est défini par une fonction totale $f$ de $E$ dans $\bdB$. Chaque éléments $c\in E$ du domaine d'entrée est appelé une instance du problème.
        
        On dis qu'un tel problème est décidable si $f$ est calculable. Sinon; le problèmes est dit indécidable. Si $A$ est un algorithme calculant $f$, on dis que $A$ résout le problème de décision.
    \end{definition}
    
    \begin{example}
        Les problèmes suivants sont décidables.
        \begin{enumerate}
            \itt\hg{Entrée :} un tableau $t$ d'entiers.
            
                \hg{Effet :} déterminer si $t$ contient des doublons.
                
            \itt\hg{Entrée :} un entier $n \in \bdN$.
            
                \hg{Effet :} déterminer si $n$ est premier.
                
            \itt\hg{Entrée :} un graphe pondéré $G$, deux sommets $s$ et $t$.
            
                \hg{Effet :} donner le plus court chemin de $s$ à $t$ dans $G$.
        \end{enumerate}
    \end{example}
    
    
\end{document}