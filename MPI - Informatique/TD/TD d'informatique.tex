\documentclass[a4paper,french,bookmarks]{book}

\usepackage{booktabs}
\usepackage{minitoc}
\usepackage{./Structure/4PE18TEXTB}
\usepackage{proof}
\usepackage{pdfpages}

\newboxans
\renewcommand{\questionsdecours}{\section*{\centering\EBGaramond\Large Questions~ de~ cours}}
\renewcommand{\thechapter}{\Roman{chapter}}
\renewcommand{\thesection}{\Roman{section}}
\renewcommand{\thesubsection}{Exercice \arabic{subsection}}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{0}
\mtcsettitle{minitoc}{}
\setlist[enumerate]{font=\color{white5!60!black}\bfseries\sffamily}
\usepackage{lscape}
%\renewcommand{\thesection}{\hspace{-11pt}}
%\renewcommand{\thesubsection}{}

\newcommand{\chaptertoc}[0]{
    \setcounter{minitocdepth}{4}
    \begin{tcolorbox}[
        enhanced,
        frame hidden,
        sharp corners,
        detach title,
        spread outwards     = 5pt,
        halign              = center,
        valign              = center,
        borderline west     = {3pt}{0pt}{main20!50!main2!95!gray!90},
        coltitle            = main20!50!main2!95!gray!90, 
        interior style      = {
            left color      = main1white2!65!gray!11,
            middle color    = main1white2!50!gray!10,
            right color     = main1white2!35!gray!9
        },
        arc                 = 0 cm,
        title               = SOMMAIRE,
        fonttitle           = \bfseries\sffamily,
        overlay             = {
            \node[rotate=90, minimum width=1cm, anchor=south,yshift=-0.8cm] at (frame.west) {\tcbtitle};
        }
    ]
        \begin{minipage}{0.83\linewidth}
            \sffamily
            \minitoc
        \end{minipage}
    \end{tcolorbox}
}

\begin{document}
    
    %==============================
    % METADONNEES
    %==============================
    
    \title{TD d'Informatique de MPI/MPI* (2022-2023)}
    \author{SIAHAAN--GENSOLLEN Rémy}
    \date{\today}
    \hypersetup{
        pdftitle={TD d'Informatique de MPI/MPI* (2022-2023)},
        pdfauthor={SIAHAAN--GENSOLLEN Rémy},
        pdflang={fr-FR},
        pdfsubject={MPI/MPI*, TD d'Informatique},
        pdfkeywords={MPI/MPI*, TD d'Informatique, 2022-2023}
        pdfstartview=
    }
    
    %==============================
    % MISE EN PAGE
    %==============================
    
    \titleformat{\chapter}[display]{\normalfont\huge\bfseries}{}{0pt}{
        \begin{tcolorbox}[
            enhanced,
            frame hidden,
            sharp corners,
            spread sidewards    = 5pt,
            halign              = center,
            valign              = center,
            interior style      = {color=main3!20},
            arc                 = 0 cm,
            fontupper           = \color{black}\sffamily\bfseries\huge,
            fonttitle           = \normalfont\color{white}\sffamily\small,
            top                 = 1cm, 
            bottom              = 0.7cm,
            title               = Chapitre \thechapter,
            attach boxed title to bottom center = {
                yshift=\tcboxedtitleheight/2,
            },
            boxed title style = {
                frame code={
                \path[left color=main3!95!gray!90,right color=main3!95!gray!90] 
                    ([xshift=-10mm]frame.north west) -- 
                    ([xshift=10mm]frame.north east) -- 
                    ([xshift=10mm]frame.south east) -- 
                    ([xshift=-10mm]frame.south west) -- 
                    cycle;
                },
                interior engine=empty
            }
        ]
            #1
        \end{tcolorbox}%
    }
    \titlespacing*{\chapter}{0pt}{-120pt}{-15pt}
    \titleformat{name=\chapter,numberless}[display]{\normalfont\huge\bfseries}{}{0pt}{
        \begin{tcolorbox}[
            enhanced,
            frame hidden,
            sharp corners,
            spread sidewards    = 5pt,
            halign              = center,
            valign              = center,
            interior style      = {color=main3!20},
            arc                 = 0 cm,
            outer arc           = 0pt,
            leftrule            = 0pt,
            rightrule           = 0pt,
            fontupper           = \color{black}\sffamily\bfseries\huge,
            enlarge left by     = -1in-\hoffset-\oddsidemargin, 
            enlarge right by    = -\paperwidth+1in+\hoffset+\oddsidemargin+\textwidth,
            width               = \paperwidth, 
            left                = 1in+\hoffset+\oddsidemargin, 
            right               = \paperwidth-1in-\hoffset-\oddsidemargin-\textwidth,
            top                 = 1cm, 
            bottom              = 1cm
        ]
            #1
        \end{tcolorbox}%
    }
    \titlespacing*{name=\chapter,numberless}{0pt}{-115pt}{0pt}
    
    %==============================
    % PREMIERE DE COUVERTURE
    %==============================

    %\includepdf[pages={1},scale=1.15,offset=0mm -18mm]{LDCCover.pdf}
    
    %==============================
    % PAGE VIDE
    %==============================
    
    %\pagestyle{empty}
    
    %==============================
    % PAGE DE COUVERTURE INTERNE
    %==============================
    
    \begin{titlepage}
	    \begin{center}
	        {\scshape SIAHAAN--GENSOLLEN Rémy\par}
	        \vspace{2cm}
	        {\huge\sffamily TD d'\par}
	        \vspace{0.5cm}
	        {\Huge\bfseries\sffamily INFORMATIQUE\par}
	        \vspace{1cm}
	        {\Large\textit{donné pendant mon année de \textsf{MPI/MPI*} à
	        Janson-de-Sailly}\\[5pt]\texttt{(2022-2023)}\par}
	        \vfill
	        {\large\EBGaramond Dernière compilation le \today\par}
        \end{center}
    \end{titlepage}
    
    %==============================
    % PAGE VIDE
    %==============================
    
    \pagestyle{empty}\text{}\newpage
    
    %==============================
    % STYLE DES EN-TÊTES ET PIEDS DE PAGES
    %==============================
    
    \renewcommand\chaptermark[1]{\markboth{#1}{}}
    
    \fancypagestyle{intro}{
        \fancyhf{}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}\fancyfoot[RO,LE]{\GillSansMTMedium\color{white5}\thepage\;/\;\pageref{LastPage}}
        \fancyhead[LE]{\GillSansMTMedium\color{white5}\bfseries TD D'INFORMATIQUE}
        \fancyhead[RE]{\GillSansMTMedium\color{white5}Avant-propos}
        \fancyhead[LO]{\GillSansMTMedium\color{white5}\rightmark}
        \fancyhead[RO]{\GillSansMTMedium\color{white5}\textbf{MPI/MPI*} 2022-2023 \quad Janson-de-Sailly}
    }
    
    \fancypagestyle{toc}{
        \fancyhf{}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}\fancyfoot[RO,LE]{\GillSansMTMedium\color{white5}\thepage\;/\;\pageref{LastPage}}
        \fancyhead[LE]{\GillSansMTMedium\color{white5}\bfseries TD D'INFORMATIQUE}
        \fancyhead[RE]{\GillSansMTMedium\color{white5}Table des matières}
        \fancyhead[LO]{\GillSansMTMedium\color{white5}\rightmark}
        \fancyhead[RO]{\GillSansMTMedium\color{white5}\textbf{MPI/MPI*} 2022-2023 \quad Janson-de-Sailly}
    }
    
    \fancypagestyle{plain}{
        \fancyhf{}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}\fancyfoot[RO,LE]{\GillSansMTMedium\color{white5}\thepage\;/\;\pageref{LastPage}}
        \fancyhead[LE]{\GillSansMTMedium\color{white5}\bfseries TD D'INFORMATIQUE}
        \fancyhead[RE]{\GillSansMTMedium\color{white5}Chapitre \thechapter : \nouppercase{\leftmark}}
        \fancyhead[LO]{\GillSansMTMedium\color{white5}\nouppercase{\rightmark}}
        \fancyhead[RO]{\GillSansMTMedium\color{white5}\textbf{MPI/MPI*} 2022-2023 \quad Janson-de-Sailly}
    }
    
    %==============================
    % PREFACE 
    %==============================
    
    \chapter*{Avant-propos}
    \thispagestyle{intro}
    \addcontentsline{toc}{chapter}{Avant-propos}
    
    \text{\Large\EBGaramond\itshape À tout lecteur potentiel, quelques mots...}\newline\newline\newline
    
    \begin{center}
        \begin{minipage}{0.85\linewidth}
            \large \qquad Ce livre contient la résolution des exercices de TD donnés pendant les cours d'informatique de mon année de MPI/MPI*. Il vient en complément du livre de cours associé.\newline\newline\newline\text{}
        \end{minipage}
    \end{center}
    
    \hfill{\large\textsc{Siahaan--Gensollen Rémy}}
    
    \pagestyle{intro}
    
    %==============================
    % TABLE DES MATIERES
    %==============================
    
    \newpage
    \dominitoc\nomtcrule 
    {\sffamily\tableofcontents}\mtcaddchapter\pagestyle{toc}
    
    \cleardoublepage
    
    %==============================
    % COURS
    %==============================
    
    \pagestyle{plain}
    
    \chapter{Logique et systèmes de preuve}
    
    \section{Révisions MP2I}
    
    \textbf{Exercice 1.} Soit $\varphi = \p{\p{x_1 \rightarrow \neg x_2} \rightarrow \neg x_1} \land x_3$.
    
    \begin{enumerate}
        \item Ecrire l'arbre syntaxique de $\varphi$.
        
        \boxansconc{
            On a l'arbre syntaxique suivant :
            %
            \begin{center}
                \begin{tikzpicture}[nodes={}, ->,
                    level 1/.style = {sibling distance = 4cm},
                    level 2/.style = {sibling distance = 3cm},
                    level 3/.style = {sibling distance = 2cm},
                ]
            
            \node[circle, fill=main3,draw=white,text=white]{$\land$}
                child {
                    node[circle, fill=main3,draw=white,text=white]{$\rightarrow$}
                    child {
                        node[circle, fill=main3,draw=white,text=white]{$\rightarrow$}
                        child { node {$x_1$} }
                        child {
                            node[circle, fill=main3,draw=white,text=white]{$\neg$}
                            child { node {$x_2$} }
                        }
                    }
                    child {
                        node[circle, fill=main3,draw=white,text=white]{$\neg$}
                        child { node {$x_1$} }
                    }
                }
                child { 
                    node {$x_3$}
                };
            \end{tikzpicture}
            \end{center}
        }
        
        \item Donner la table de vérité de $\varphi$.
        
        \boxansconc{
            On a la table de vérité suivante :
            %
            \begin{center}
            \NiceMatrixOptions{cell-space-top-limit=3pt}
            \begin{NiceTabular}{|ccc|ccc|}[]
                \CodeBefore
                    \rowcolor{main3!10}{1}
                    \rectanglecolor{main20!15}{2-4}{9-6}
                    \cellcolor{main3!15}{4-4, 5-4, 2-5, 3-5, 2-6, 3-6, 5-6, 7-6, 9-6}
                \Body
                    \toprule
                    $x_1$ & $x_2$ & $x_3$ & $x_1 \rightarrow \neg x_2$ & $\p{x_1 \rightarrow \neg x_2} \rightarrow \neg x_1$ & $\p{\p{x_1 \rightarrow \neg x_2} \rightarrow \neg x_1} \land x_3$ \\ \midrule
                    1 & 0 & 1 & 1 & 0 & 0\\
                    1 & 0 & 0 & 1 & 0 & 0\\
                    1 & 1 & 1 & 0 & 1 & 1\\
                    1 & 1 & 0 & 0 & 1 & 0\\
                    0 & 0 & 1 & 1 & 1 & 1\\
                    0 & 0 & 0 & 1 & 1 & 0\\
                    0 & 1 & 1 & 1 & 1 & 1\\
                    0 & 1 & 0 & 1 & 1 & 0\\
                    \bottomrule
            \end{NiceTabular}
            \end{center}
        }
        
    \item $\varphi$ est-elle valide ? Est-elle satisfiable ?
    
    \noafter
    %
    \boxans{
        Soit $\bcv$ la valuation telle que $\bcv \vDash x_1$, $\bcv \vDash x_2$, $\bcv \vDash x_3$. D'après la table ci-dessus, on a $\bcv \vDash \varphi$.
        
        Soit $\bcv$ la valuation telle que $\bcv \vDash x_1$ et $\bcv \vDash x_3$, mais $\bcv\p{x_2} = 0$. D'après la table, $\bcv\p{\varphi} = 0$.
    }
    %
    \nobefore\yesafter
    %
    \boxansconc{
        Il existe une valuation qui satisfait $\varphi$ et une qui ne la satisfait pas, donc $\varphi$ est satisfiable mais pas valide.
    }
    %
    \yesbefore
    
    \item Donner la forme normale disjonctive canonique de $\varphi$.
    
    \boxansconc{
        On a en utilisant la table de vérité :
        %
        \[ \varphi = \p{x_1 \land x_2 \land x_3} \lor \p{\neg x_1 \land \neg x_2 \land x_3} \lor \p{\neg x_1 \land x_2 \land x_3}\]
    }
    
    \item Donner la forme normale conjonctive canonique de $\varphi$.
    
    \boxansconc{
        On a en utilisant la table de vérité :
        %
        \[ \varphi = \p{\neg x_1 \lor x_2 \lor \neg x_3} \land \p{\neg x_1 \lor x_2 \lor x_3} \land \p{\neg x_1 \lor \neg x_2 \lor x_3} \land \p{x_1 \lor x_2 \lor x_3} \land \p{x_1 \lor \neg x_2 \lor x_3}\]
    }
    \end{enumerate}
    
    \textbf{Exercice 2.} Pour les formules suivantes, dire si ce sont ou non des tautologies. Dans le cas d'une réponse négative, exhiber un contre modèle.
    
    \begin{enumerate}
        \begin{minipage}[t]{0.48\linewidth}
            \item $\p{p_1 \rightarrow p_1} \rightarrow p_2$
            
            \boxansconc{
                Ce n'est pas une tautologie : $p_2$ faux est un contre modèle.
            }
            
            \item $\p{p_1 \rightarrow p_2} \rightarrow p_1$
            
            \boxansconc{
                Ce n'est pas une tautologie : $p_1$ faux est un contre modèle.
            }
            
            \item $\p{p_2 \rightarrow p_1} \rightarrow p_1$
            
            \boxansconc{
                Ce n'est pas une tautologie : $p_2$ et $p_1$ faux est un contre modèle.
            }
            
            \item $\p{\neg p_1 \rightarrow p_1} \rightarrow p_1$
            
            \boxansconc{
                C'est une tautologie.
            }
            
            \item $\p{p_1 \rightarrow p_2} \rightarrow \p{\p{p_1 \land p_3} \rightarrow p_2}$
            
            \boxansconc{
                C'est une tautologie.
            }
        \end{minipage}
        %
        \hfill
        %
        \begin{minipage}[t]{0.48\linewidth}
            \item $p_1 \rightarrow \p{p_1 \rightarrow p_2}$
            
            \boxansconc{
                Ce n'est pas une tautologie : $p_1$ vrai et $p_2$ faux est un contre modèle.
            }
            
            \item $p_1 \rightarrow \p{p_2 \rightarrow p_1}$
            
            \boxansconc{
                C'est une tautologie.
            }
            
            \item $p_2 \rightarrow \p{p_1 \rightarrow p_1}$
            
            \boxansconc{
                C'est une tautologie.
            }
            
            \item $\p{\p{p_1 \lor p_3} \rightarrow p_2} \rightarrow \p{\p{p_4 \rightarrow p_1} \rightarrow \p{p_4 \rightarrow p_2}}$
            
            \boxansconc{
                C'est une tautologie.
            }
            
            \item $\p{p_1 \rightarrow p_2} \rightarrow \neg\p{p_1 \land \neg p_2}$
            
            \boxansconc{
                C'est une tautologie.
            }
        \end{minipage}
        
    \end{enumerate}
    
    \textbf{Exercice 3.} Donner la forme normale disjonctive (resp. conjonctive) canonique des formules de l'exercice 2.
    
    \boxansconc{
        \begin{enumerate}
            \begin{minipage}[t]{0.48\linewidth}
                \item Disjonctive : $\p{p_1 \land p_2} \lor \p{\neg p_1 \land p_2}$ 
            
                Conjonctive : $\p{p_1 \lor p_2} \land \p{\neg p_1 \lor p_2}$
            
                \item Disjonctive : $\p{p_1 \land p_2} \lor \p{p_1 \land \neg p_2}$ 
            
                Conjonctive : $\p{p_1 \lor p_2} \land \p{p_1 \lor \neg p_2}$
            
                \item Disjonctive : $\p{p_1 \land p_2} \lor \p{p_1 \land \neg p_2} \lor \p{\neg p_1 \land p_2}$
            
                Conjonctive : $p_2 \lor p_1$
            
                \item Tautologie
            
                \item Tautologie
            \end{minipage}
            %
            \hfill
            %
            \begin{minipage}[t]{0.48\linewidth}
                \item Disjonctive : $\p{p_1 \land p_2} \lor \p{\neg p_1 \lor p_2} \lor \p{\neg p_1 \lor \neg p_2}$
                
                Conjonctive : $\neg p_1 \lor p_2$ 
                
                \item Tautologie
                
                \item Tautologie
                
                \item Tautologie
                
                \item Tautologie
            \end{minipage}
        \end{enumerate}
    }
    
    \textbf{Exercice 4.} On définit le connecteur de \textsc{Scheffer}, ou d'incompatibilité, par $x_1 \diamond x_2 = \neg x_1 \lor \neg x_2$.
    
    \begin{enumerate}
        \item Construire la table de vérité de $\diamond$.

        \boxansconc{
            On a la table de vérité suivante :
            %
            \begin{center}
            \NiceMatrixOptions{cell-space-top-limit=3pt}
            \begin{NiceTabular}{|cc|c|}[]
                \CodeBefore
                    \rowcolor{main3!10}{1}
                    \rectanglecolor{main20!15}{2-3}{5-3}
                    \cellcolor{main3!15}{3-3}
                \Body
                    \toprule
                    $x_1$ & $x_2$ & $\neg x_1 \lor \neg x_2$ \\ \midrule
                    1 & 0 & 1\\
                    1 & 1 & 0\\
                    0 & 1 & 1\\
                    0 & 0 & 1\\
                    \bottomrule
            \end{NiceTabular}
            \end{center}
        }

        \item Donner une formule équivalente à $x_1 \diamond x_2$ n'utilisant que les connecteurs $\neg$ et $\land$.

        \noafter
        %
        \boxans{
            On a $x_1 \diamond x_2 \equiv \neg x_1 \lor \neg x_2 \equiv \neg\p{\neg\p{\neg x_1 \lor \neg x_2}}$. Par formule de \textsc{De Morgan}, on a $x_1 \diamond x_2 \equiv \neg\p{\neg\p{\neg x_1} \land \neg\p{\neg x_2}}$, soit :
        }
        %
        \nobefore\yesafter
        %
        \boxansconc{
            \[ x_1 \diamond x_2 \equiv \neg\p{x_1 \land x_2}\]
        }
        \yesbefore

        \item Donner une formule équivalente à $\neg x_1$ n'utilisant que le connecteur $\diamond$.
        
        \boxansconc{
            On a $\neg x_1 \equiv x_1 \diamond \top$.
        }
        
        \item Démontrer par induction structurelle que toute formule propositionnelle est équivalente à une formule utilisant uniquement le connecteur $\diamond$.
        
        \noafter
        %
        \boxans{
            Soit $\bcV$ un ensemble de variables propositionnelles et $\Gamma$ l'ensemble des formules propositionnelles à variables dans $\bcV$, défini par induction. On construit l'application $\bch : \Gamma \to \Gamma$ telle que :
            %
            \begin{enumerate}
                \itast $\bch\p{\top} = \top \equiv \top$ et  $\bch\p{\bot} = \bot \equiv \bot$
                \itast $\forall v \in \bcV$, \qquad $\bch\p{v} = v$
                \itast $\forall \p{\varphi, \psi} \in \Gamma^2,\qquad \left\lbrace\begin{array}{ccccc}
                    \bch\p{\neg \varphi} &=& \varphi \diamond \top &\equiv& \neg \varphi \\
                    \bch\p{\varphi \land \psi} &=& \p{\varphi \diamond \psi} \diamond \top &\equiv& \varphi \land \psi\\
                    \bch\p{\varphi \lor \psi} &=& \p{\varphi \diamond \top} \diamond \p{\psi \diamond \top} &\equiv& \varphi \lor \psi\\
                    \p{\varphi \rightarrow \psi} &=& \varphi \diamond \p{\psi \diamond \top} &\equiv& \varphi \rightarrow \psi
                \end{array}\right.$
            \end{enumerate}
            %
            On vérifie facilement que $\bch\p{\Gamma}$ ne contient que des formules utilisant uniquement le connecteur $\diamond$. De plus pour tout $\varphi \in \Gamma$, on a $\bch\p{\varphi} \equiv \varphi$, ainsi :
        }
        %
        \nobefore\yesafter
        %
        \boxansconc{
            Toute formule propositionnelle $\varphi$ est équivalente à une formule $\bch\p{\varphi}$ utilisant uniquement le connecteur $\gamma$.
        }
        \yesbefore
    \end{enumerate}
    
    \textbf{Exercice 5.} Montrer que toute formule propositionnelle est équivalente à une formule utilisant uniquement le connecteur $\rightarrow$.
    
    \noafter
    %
    \boxans{
        On a $x_1 \rightarrow x_2 \equiv \neg x_1 \lor x_2$ ce qui livre $\neg x_1 \equiv x_1 \rightarrow \bot$ et $x_1 \rightarrow x_2 \equiv \neg\p{x_1 \land \neg x_2}$. On procède donc par induction.
        
        Soit $\bcV$ un ensemble de variables propositionnelles et $\Gamma$ l'ensemble des formules propositionnelles à variables dans $\bcV$, défini par induction. On construit l'application $\bch : \Gamma \to \Gamma$ telle que :
            %
            \begin{enumerate}
                \itast $\bch\p{\top} = \top \equiv \top$ et  $\bch\p{\bot} = \bot \equiv \bot$
                \itast $\forall v \in \bcV$, \qquad $\bch\p{v} = v$
                \itast $\forall \p{\varphi, \psi} \in \Gamma^2,\qquad \left\lbrace\begin{array}{ccccc}
                    \bch\p{\neg \varphi} &=& \varphi \rightarrow \bot &\equiv& \neg \varphi \\
                    \bch\p{\varphi \land \psi} &=& \p{\varphi \rightarrow \p{\psi \rightarrow \bot}} \rightarrow \bot &\equiv& \varphi \land \psi\\
                    \bch\p{\varphi \lor \psi} &=& \p{\varphi \rightarrow \bot} \rightarrow \psi &\equiv& \varphi \lor \psi
                \end{array}\right.$
            \end{enumerate}
            %
            On vérifie facilement que $\bch\p{\Gamma}$ ne contient que des formules utilisant uniquement le connecteur $\rightarrow$. De plus pour tout $\varphi \in \Gamma$, on a $\bch\p{\varphi} \equiv \varphi$, ainsi :
    }
    %
    \nobefore\yesafter
    %
    \boxansconc{
        Toute formule propositionnelle $\varphi$ est équivalente à une formule $\bch\p{\varphi}$ utilisant uniquement le connecteur $\gamma$.
    }
    %
    \yesbefore
    
    \textbf{Exercice 6.} Appliquer l'algorithme de \textsc{Quine} aux formules suivantes, et dire si elles sont satisfiables (resp. valides) :
     
    \begin{enumerate}
        \begin{minipage}{0.48\linewidth}
            \item $\p{a \rightarrow b} \lor \p{b \rightarrow a}$
            
            
             
            \item $\p{\p{a \rightarrow b} \rightarrow a} \rightarrow a$
            
            \boxans{
                Avec $\top \mid a$ :
                %
                \begin{align*}
                    \p{\p{a \rightarrow b} \rightarrow a} \rightarrow a &\equiv \p{\p{\top \rightarrow b} \rightarrow \top} \rightarrow \top\\
                    &\equiv \p{b \rightarrow \top} \rightarrow \top\\
                    &\equiv \top \rightarrow \top &\equiv \top
                \end{align*}
                %
                Avec $\bot \mid a$ :
                %
                \begin{align*}
                    \p{\p{a \rightarrow b} \rightarrow a} \rightarrow a &\equiv \p{\p{\bot \rightarrow b} \rightarrow \bot} \rightarrow \bot\\
                    &\equiv \p{\top \rightarrow \bot} \rightarrow \bot\\
                    &\equiv \bot \rightarrow \bot &\equiv \top
                \end{align*}
            }
             
            \item $\p{\p{a \rightarrow b} \rightarrow a} \rightarrow b$
             
            \item $a \rightarrow \p{\p{a \rightarrow b} \rightarrow b}$
             
            \item $\p{\p{x_1 \rightarrow \neg x_2} \rightarrow \neg _1} \lor x_3$
             
            \item $\p{\p{p_1 \lor p_3} \rightarrow p_2} \rightarrow \p{\p{p_4 \rightarrow p_1} \rightarrow \p{p_4 \rightarrow p_2}}$
    \end{minipage}
    %
    \hfill
    %
    \begin{minipage}{0.48\linewidth}
        \item $\p{\neg a \lor \p{b \land c}} \land \p{\p{a \land \neg b} \lor \p{a \land \neg c}}$
             
        \item $\p{a \rightarrow b} \rightarrow \p{\p{b \rightarrow c} \rightarrow \p{a \rightarrow c}}$
             
        \item $\p{\p{a \land \neg b} \lor \p{a \rightarrow \p{b \lor c}}} \rightarrow \p{\neg a \land \neg c}$
             
        \item $\p{\p{s \rightarrow \p{b \lor t}} \land \p{\p{b \lor a} \rightarrow \p{r \land m}} \land \neg r} \rightarrow \p{s \rightarrow t}$
             
        \item $\p{\p{p \rightarrow q} \lor \p{\neg p \rightarrow \neg q}} \land \p{q \land r \rightarrow \neg p}$
    \end{minipage}
    \end{enumerate}
    
     \textbf{Exercice 7.} Montrer les conséquences logiques suivantes :
     
     \begin{enumerate}
         \item $\p{p \land q \lor r \land \neg\p{q \lor s}} \lor \neg q \land \p{s \rightarrow p} \vDash q \rightarrow p$
         
         \item $\varphi \vDash \psi \rightarrow \varphi$
         
         
         \noafter
         %
         \boxans{
            Soit $\bcv$ une valuation telle que $\bcv \vDash \varphi$, donc $\bcv\p{\varphi} = 1$. On a :
            %
            \[ \bcv\p{\psi \rightarrow \varphi} = \bcv\p{\neg \psi \lor \varphi} = \bcv\p{\neg \psi} + \bcv\p{\varphi} - \bcv\p{\neg \psi}\bcv\p{\varphi} = \bcv\p{\neg \psi} + 1 - \bcv\p{\neg \psi} = 1\]
            %
         }
         %
         \nobefore\yesafter
         %
         \boxansconc{
            Donc $\bcv \vDash \psi \rightarrow \varphi$, ainsi on a bien $\varphi \vDash \psi \rightarrow \varphi$.
         }
         %
         
         \item $\varphi, \varphi \rightarrow \psi \vDash \psi$
    \end{enumerate}
    
    \section{Logique du premier ordre}
    
    \textbf{Exercice 1.} Soit :
    %
    \begin{enumerate}
        \itt $a$ et $b$ des symboles de constantes ;
        \itt $f$ (resp. $R$) un symbole de fonction (resp. relation) unaire ;
        \itt $g$ (resp. $S$) un symbole de fonction (resp. relation) binaire.
    \end{enumerate}
    
    Les expressions suivantes sont-elles des termes ? Des formules ? Si oui, quelle en est la taille ? Si c'est une formule quelles sont ses variables livres et ses variables liées ?
    
    \begin{enumerate}
        \item $g\p{a, f\p{b}}$
        
        \item $f\p{g\p{f\p{x}, g\p{a, f\p{y}}}}$
    \end{enumerate}
    
    \textbf{Exercice 4.} Démontrer les formules suivantes à l'aide de la déduction naturelle ;
    %
    \begin{enumerate}
        \item $\exists x \  \p{\varphi \land \psi} \rightarrow \p{\exists x \ \varphi} \land \p{\exists x \ \psi}$
        %
        \boxansconc{
            \[ 
                \infer[(\rightarrow_i)]{\exists x \  \p{\varphi \land \psi} \rightarrow \p{\exists x \ \varphi} \land \p{\exists x \ \psi}}{
                    \infer[(\land_i)]{\exists x \ \p{\varphi \land \psi} \vdash \p{\exists x \ \varphi} \land \p{\exists x \ \varphi}}{
                        \infer[(\exists_i)]{\exists x \ \p{\varphi \land \psi} \vdash \exists x \ \varphi}{
                            \infer[(\land_e^d)]{\exists x \ \p{\varphi \land \psi} \vdash \varphi}{
                                \infer[]{\exists x \ \p{\varphi \land \psi} \vdash \varphi \land \psi}{
                                }
                            }
                        } &
                        \infer[(\exists_i)]{\exists x \ \p{\varphi \land \psi} \vdash \exists x \ \varphi}{
                        }
                    }
                }
            \]
        }
        
    
     \textbf{Exercice 6.} Soit $f\p{1}$ un symbole de fonction et $T\p{2}$ un symbole de relation. Montrer $\varphi_1, \varphi_2, \varphi_3 \vdash \varphi$, où :
     %
     \begin{enumerate}
         \itt $\varphi_1 : \forall x \p{\p{\exists y \ T\p{x, y}} \to T\p{x, f\p{x}}}$
         
         \itt $\varphi_2 : \forall x \p{\exists y \ T\p{x, y}}$
         
         \itt $\varphi_3 : \exists x \ T\p{f\p{f\p{x}}, x}$
         
         \itt $\varphi : \exists x \exists y \exists z \p{T\p{x, y} \land T\p{y, z} \land T\p{z, x}}$
         
         \
         \boxansconc{
            On pose :
            %
            \begin{enumerate}
                \itt $\varphi_1' : \p{\exists y \ T\p{x, y}} \to T\p{x, f\p{x}}$
                
                \itt $\varphi_2' : \exists y \ T\p{x, y}$
                
                \itt $\varphi_3' : T\p{f\p{f\p{x}}, x}$
                
                \itt $\varphi_4' : T\p{x, f\p{x}}$
            \end{enumerate}
            
         }
     \end{enumerate}
    \end{enumerate}
    \newpage
    
    \begin{landscape}
    On pose les formules :
    %
    \begin{enumerate}
        \begin{minipage}{0.48\linewidth}
            \itt $\varphi_1' : \p{\exists y \ T\p{x, y}} \to T\p{x, f\p{x}}$
                
            \itt $\varphi_2' : \exists y \ T\p{x, y}$
                
            \itt $\varphi_3' : T\p{f\p{f\p{x}}, x}$
                
            \itt $\varphi_4' : T\p{x, f\p{x}}$
        \end{minipage}
        %
        \hfill
        %
        \begin{minipage}{0.48\linewidth}
            \itt $\phi_1 : \varphi_1'\intc{x := f\p{x}}$
            
            \itt $\phi_2 : \varphi_2' \intc{x := f\p{x}}$
            
            \itt $\phi_4 : \varphi_4'\intc{x := f\p{x}}$
        \end{minipage}
                
    \end{enumerate}
    %
    On a alors :
    %
    \[  \resizebox{\linewidth}{!}{
                \infer[(\exists_e)]{
                    \varphi_1, \varphi_2, \varphi_3 \vdash \varphi
                }{
                    \infer[(Ax)]{
                        \varphi_1, \varphi_2, \varphi_3 \vdash \varphi_3
                    }{} &
                    \infer[(\rightarrow_e)]{
                        \varphi_1, \varphi_2, \varphi_3, \varphi_3' \vdash \varphi
                    }{
                        \infer[(\forall_e)]{
                            \varphi_1, \varphi_2, \varphi_3, \varphi_3' \vdash \varphi_1'
                        }{
                            \infer[(Ax)]{
                                \varphi_1, \varphi_2, \varphi_3, \varphi_3' \vdash \varphi_1
                            }{}
                        } &
                        \infer[(\rightarrow_i)]{
                            \varphi_1, \varphi_2, \varphi_3, \varphi_3' \vdash \varphi_1' \rightarrow \varphi
                        }{
                            \infer[(\rightarrow_e)]{
                                \varphi_1, \varphi_2, \varphi_3, \varphi_1', \varphi_3' \vdash \varphi
                            }{
                                \infer[(\forall e)]{
                                    \varphi_1, \varphi_2, \varphi_3, \varphi_1', \varphi_3' \vdash \varphi_2'
                                }{
                                    \infer[(Ax)]{
                                        \varphi_1, \varphi_2, \varphi_3, \varphi_1', \varphi_3' \vdash \varphi_2
                                    }{}
                                } & 
                                \infer[(\rightarrow_i)]{
                                    \varphi_1, \varphi_2, \varphi_3, \varphi_1', \varphi_3' \vdash \varphi_2' \rightarrow \varphi
                                }{
                                    \infer[(Aff)]{
                                        \varphi_1, \varphi_2, \varphi_3, \varphi_1', \varphi_2', \varphi_3' \vdash \varphi
                                    }{
                                        \infer[(Abs)]{
                                            \varphi_1, \varpi_2, \varphi_1', \varphi_2', \varphi_3' \vdash \varphi
                                        }{
                                            \infer[(\neg_e)]{
                                                \varphi_1, \varphi_2, \varphi_1', \varphi_2', \varphi_3', \neg \varphi \vdash \bot
                                            }{
                                                \infer[(\rightarrow_e)]{
                                                    \varphi_1, \varphi_2, \varphi_1', \varphi_2', \varphi_3', \neg \varphi \vdash T\p{x, f\p{x}}
                                                }{
                                                    \infer[(Ax)]{
                                                    \varphi_1, \varphi_2, \varphi_1', \varphi_2', \varphi_3', \neg \varphi \vdash \varphi_1'
                                                    }{} &
                                                    \infer[(Ax)]{
                                                    \varphi_1, \varphi_2, \varphi_1', \varphi_2', \varphi_3', \neg \varphi \vdash \varphi_2'
                                                    }{}
                                                } &
                                                \infer[(\neg_i)]{
                                                    \varphi_1, \varphi_2, \varphi_1', \varphi_2', \varphi_3', \neg \varphi \vdash \neg T\p{x, f\p{x}}
                                                }{
                                                    \infer[(\neg_e)]{
                                                        \varphi_1, \varphi_2, \varphi_1', \varphi_2', \varphi_3', \neg \varphi, T\p{x, f\p{x}} \vdash \bot
                                                    }{
                                                        \infer[(Ax)]{
                                                            \varphi_1, \varphi_2, \varphi_1', \varphi_2', \varphi_3', \neg \varphi, T\p{x, f\p{x}} \vdash \varphi
                                                        }{} &
                                                        \infer[(Aff)]{
                                                            \varphi_1, \varphi_2, \varphi_1', \varphi_2', \varphi_3', \neg \varphi, T\p{x, f\p{x}} \vdash \varphi
                                                        }{
    \infer[(\rightarrow_e)]{
        \varphi_1, \varphi_2, \varphi_3', \varphi_4' \vdash \varphi
    }{
        \infer[(\forall_e)]{
            \varphi_1, \varphi_2, \varphi_3',\varphi_4' \vdash \varphi_1'\intc{x := f\p{x}}
        }{
            \infer[(Ax)]{
                \varphi_1, \varphi_2, \varphi_3',\varphi_4' \vdash \varphi_1
            }{}
        } &
        \infer[(Aff)]{
            \varphi_1, \varphi_2, \varphi_3', \varphi_4' \vdash \phi_1' \rightarrow \varphi
        }{
            \infer[(\rightarrow_i)]{
                \varphi_2, \varphi_3', \varphi_4' \vdash \phi_1 \rightarrow \varphi
            }{
                \infer[(\rightarrow_i)]{
                    \phi_1, \varphi_2, \varphi_3', \varphi_4' \vdash \varphi
                }{
                    \infer[(Abs)]{
                        \phi_1, \phi_2, \varphi_3', \varphi_4' \vdash \varphi
                    }{
                        \infer[(\rightarrow_e)]{
                            \phi_1, \phi_2, \varphi_3', \varphi_4, \neg \varphi \vdash \phi_4
                        }{
                            \infer[(Ax)]{
                                \phi_1, \phi_2, \varphi_3', \varphi_4, \neg \varphi \vdash \phi_1
                            }{} &
                            \infer[(Ax)]{
                                \phi_1, \phi_2, \varphi_3', \varphi_4, \neg \varphi \vdash \phi_2
                            }{}
                        } &
                        \infer[(Aff)]{
                            \phi_1, \phi_2, \varphi_3', \varphi_4', \neg \varphi \vdash \neg \phi_4
                        }{
                            \infer[(\neg_i)]{
                                \varphi_3', \varphi_4', \neg \varphi \vdash \neg \phi_4
                            }{
                                \infer[(\neg_e)]{
                                    \varphi_3', \varphi_4', \phi_4, \neg \varphi \vdash \bot
                                }{
                                    \infer[(Ax)]{
                                        \varphi_3', \varphi_4', \phi_4, \neg \varphi \vdash \neg \varphi
                                    }{} &
                                    \infer[(Aff)]{
                                        \varphi_3', \varphi_4', \phi_4, \neg \varphi \vdash \varphi
                                    }{
                                        \infer[(\exists_i) \ \intc{x := x}]{
                                            \varphi_3', \varphi_4', \phi_4 \vdash \varphi
                                        }{
                                            \infer[(\exists_i) \ \intc{y := f\p{x}}]{
                                                \varphi_3', \varphi_4', \phi_4 \vdash \exists y \exists z \p{T\p{x, y} \land T\p{y, z} \land T\p{z, x}}
                                            }{
                                                \infer[(\exists_i) \ \intc{z := f\p{x}}]{
                                                     \varphi_3', \varphi_4', \phi_4 \vdash \exists z \ T\p{x, f\p{x}} \land T\p{f\p{x}, z} \land T\p{z, x}
                                                }{
                                                    \infer[(\land_i)]{
                                                        \varphi_3', \varphi_4', \phi_4 \vdash \varphi_4' \land \phi_4 \land \varphi_3'
                                                    }{
                                                        \infer[(Ax)]{
                                                            \varphi_3', \varphi_4', \phi_4 \vdash \varphi_4'
                                                        }{} &
                                                        \infer[(\land_i)]{
                                                            \varphi_3', \varphi_4', \phi_4 \vdash \phi_4 \land \varphi_3'
                                                        }{
                                                            \infer[(Ax)]{
                                                                \varphi_3', \varphi_4', \phi_4 \vdash \phi_4 \land \phi_4
                                                            }{} &
                                                            \infer[(Ax)]{
                                                                 \varphi_3', \varphi_4', \phi_4 \vdash \phi_4 \land \varphi_3' \vdash \varphi_3'
                                                            }{}
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
        }\]
    \end{landscape}

    \chapter{Langages formels et théorie des automates}
    
    \section{Langages réguliers}

    \subsection{Expressions régulières}
    
    Soit l'alphabet $\Sigma = \ens{a, b}$. Pour chacune des expressions régulières suivantes, donner deux mots qui sont reconnus par l'expression, et deux mots qui ne sont pas reconnus.
    
    \begin{enumerate}
        \begin{minipage}{0.45\linewidth}
            \item $a^\star b^\star$
            
            \boxansconc{
                Les mots $aabb$ et $ab$ sont reconnus, les mots $aba$ et $ba$ ne le sont pas.
            }
            
            \item $a\p{ba}^\star b$
            
            \boxansconc{
                Les mots $abab$ et $ab$ sont reconnus, les mots $b$ et $aba$ ne le sont pas.
            }
            
            \item $a^\star \vert b^\star$ 
            
            \boxansconc{
                Les mots $a$ et $b$ sont reconnus, les mots $ab$ et $ba$ ne le sont pas.
            }
            
            \item $\p{aaa}^\star$
            
            \boxansconc{
                les mots $aaa$ et $aaaaaa$ sont reconnus, les mots $a$ et $aa$ ne le sont pas.
            }
        \end{minipage}
        %
        \hfill
        %
        \begin{minipage}{0.45\linewidth}
            \item $\Sigma^\star a \Sigma^\star b \Sigma^\star a \Sigma^\star$
            
            \boxansconc{
                Les mots $aaabaaa$ et $aba$ sont reconnus, les mots $a$ et $b$ ne le sont pas.
            }
            
            \item $aba \vert bab$
            
            \boxansconc{
                Les mots $aba$ et $bab$ sont reconnus, les mots $a$ et $b$ ne le sont pas.
            }
            
            \item $\p{\epsilon \vert a}b$
            
            \boxansconc{
                Les mots $ab$ et $b$ sont reconnus, les mots $aab$ et $abb$ ne le sont pas.
            }
            
            \item $\p{a \vert ba \vert bb}\Sigma^\star$
            
            \boxansconc{
                Les mots $ab$ et $babb$ sont reconnus, les mots $b$ et $\epsilon$ ne le sont pas.
            }
        \end{minipage}
    \end{enumerate}
    
    \subsection{Opérateurs réguliers}
    
    Soient $L_1$, $L_2$ et $L_3$ des langages sur un alphabet $\Sigma$. Dire si les égalités suivantes sont vraies ou fausses :
    
    \begin{enumerate}
        \begin{minipage}{0.45\linewidth}
            \item $\bigcup\limits_{i \in \bdN} L_1^i = L_1^\star$
            
            \boxansconc{
                Vrai si et seulement si $\epsilon \in L_1$.
            }
            
            \item $L_1L_1^\star = L_1^\star \backslash \ens{\epsilon}$
            
            \boxansconc{
                Vrai si et seulement si $\epsilon \in L_1$.
            }
            
            \item $L_1^\star = \ens{\epsilon} L_1L_1^\star$
            
            \boxansconc{
                Vrai.
            }
        \end{minipage}
        %
        \hfill
        %
        \begin{minipage}{0.45\linewidth}
            \item $\p{L_2L_1}^\star L_2 = L_2\p{L_1L_2}^\star$
            
            \boxansconc{
                Vrai (par récurrence sur $n \in \bdN$)
            }
            
            \item $\p{L_1 \mid L_2}L_3 = \p{L_1L_3} \mid \p{L_2L_3}$
            
            \boxansconc{
                Vrai. \textbf{\sffamily N.B. :} On peut donc distribuer $\cdot$ sur $\vert$.
            }
            
            \item Si $L_1$ et $L_2$ sont finis : $\mod{L_1L_2} = \mod{L_1}\times\mod{L_2}$
            
            \boxansconc{
                Si on prend $L_1 = \ens{ba, baa}$ et $L_2 = \ens{ab, aab}$, on a $L_1L_2 = \ens{baab, baaab, baaaab}$, donc on a un contre-exemple, d'où la formule est fausse.
            }
        \end{minipage}
    \end{enumerate}
    
    \subsection{Expressions régulières}
    
    Soit l'alphabet $\Sigma = \ens{a, b, c, d}$. Donner une expression régulière décrivant :
    
    \begin{enumerate}
        \item L'ensemble des mots sur l'alphabet $\Sigma$.
        
        \boxansconc{
            Une telle expression serait $\Sigma^\star$ ou encore $\p{a \vert b \vert c \vert d}^\star$.
        }
        
        \item L'ensemble des mots non vides sur l'alphabet $\Sigma$.
        
        \boxansconc{
            Une telle expression serait $\p{a \vert b \vert c \vert d}\cdot\p{a \vert b \vert c \vert d}^\star$.
        }
        
        \item L'ensemble des mots sur $\Sigma$ contenant exactement un $a$ ;
        
        \boxansconc{
            Une telle expression serait $\p{b \vert c \vert d}^\star\cdot a \cdot\p{b \vert c \vert d}^\star$.
        }
        
        \item L'ensemble des mots sur $\ens{a, b}$ contenant toujours un $b$ directement après un $a$.
        
        \boxansconc{
            Une telle expression serait $\p{b^\star\p{ab}^\star}^\star$ ou encore $\p{b \mid ab}^\star$.
        }
        
        \item L'ensemble des mots ne contenant pas de $a$ après le premier $b$.
        
        \boxansconc{
            Une telle expression serait $\p{a \vert c \vert d}^\star \p{b \vert c \vert d}^\star$.
        }
        
        \item L'ensemble des mots non vides commençant par $b$ et terminant par $d$.
        
        \boxansconc{
            Une telle expression serait $b\p{a \vert b \vert c \vert d}^\star d$.
        }
        
        \item L'ensemble des mots sur $\ens{a, b, c}$ où chaque paire de $a$ est séparée par exactement 3 lettres ;
        
        \boxansconc{
            Une telle expression serait $\p{b \vert c}^\star \p{a \p{b \vert c}^3 a}^\star \p{b \vert c}^\star$.
        }
        
        \item L'ensemble des mots sur $\ens{a, b, c}$ comportant exactement deux $b$, où tout $a$ est suivi d'au moins deux $c$, et qui se terminent par $b$.
        
        \boxansconc{
            Une telle expression serait $\p{\p{ac^2 \mid c}^\star b}^2$.
        }
    \end{enumerate}
    
    \subsection{Langages réguliers}
    
    Montrer que tout langage fini est régulier.
    
    \boxansconc{
        Soit $L$ un langage fini. On considère sans perte d'information $n \in \bdN$ et $L = \ens{u_1, u_2, \dots, u_n}$. Dès lors, $L = u_1 \vert u_2 \vert \dots \vert u_n$ donc $L$ est régulier.
    }
    
    \subsection{Langages réguliers}
    
    Soit $\Sigma$ un alphabet, et $u \neq \epsilon$ un mot sur $\Sigma$. Montrer que les langages suivants sont réguliers :
    
    \begin{enumerate}
        \item $L_1$ le langage des mots qui contiennent au moins une fois une occurrence du facteur $u$.
        
        \boxansconc{
            On a $L_1 = \Sigma^\star u \Sigma^\star$, donc $L_1$ est régulier.
        }
        
        \item $L_2$ le langage des mots qui contiennent au moins deux occurrences disjointes du facteur $u$.
        
        \boxansconc{
            On a $L_2 = \Sigma^\star u \Sigma^\star u \Sigma^\star$, donc $L_2$ est régulier.
        }
        
        \item $L_3$ le langage des mots qui contiennent au moins deux occurrences non disjointes du facteur $u$.
        
        \boxansconc{
            Considérons un automate d'état initial $q_0$ et final $q_3$. Pour tout $\p{u_1, u_2, u_3} \in \p{\Sigma^\star}^3$ tels que $u = u_1u_2$ et $u = u_2u_3$, on construit le chemin suivant dans l'automate :
            
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                    \node[initial,state,initial text={}] (Q0) {$q_0$};
                    \node[state] (Q1) [right of=Q0] {$q_1$};
                    \node[state] (Q2) [right of=Q1] {$q_2$};
                    \node[state,accepting] (Q3) [right of=Q2] {$q_3$};

                    \path[->]   (Q0) edge [above] node [align=center]  {$u_1$} (Q1)
                                (Q1) edge [above] node [align=center]  {$u_2$} (Q2)
                                (Q2) edge [above] node [align=center]  {$u_3$} (Q3)
                                (Q0) edge [loop above] node [align=center]  {$\Sigma$} (Q0)
                                (Q3) edge [loop above] node [align=center]  {$\Sigma$} (Q3);
                    \end{tikzpicture}
            \end{center}
            
            Cet automate reconnaît $L_3$, d'où $L_3$ est régulier.
        }
        
        \item $L_4$ le langage des mots qui contiennent exactement une occurrence du facteur $u$
        
        \boxansconc{
            On a $L_4 = L_1 \backslash \p{L_2 \cup L_3}$ donc $L_4$ est régulier.
        }
        
        \item $L_5$ le langage des mots $w \in \Sigma^\star$ tels que $u$ est un sous-mot de $w$.
        
        \boxansconc{
            On pose $u = a_1a_2\dots a_n$. On a alors $L_5 = \Sigma^\star a_1 \Sigma^\star a_2 \Sigma^\star \dots \Sigma^\star a_n \Sigma^\star$ donc $L_5$ est régulier.
        }
        
        \item $L_6$ Le langage des mots $w \in \Sigma^\star$ tels que $w$ est un sous-mot de $u$.
    \end{enumerate}
    
    \subsection{Mots binaires}
    
    Soit l'alphabet $\Sigma = \ens{0, 1}$. On appelle \emph{mot binaire} tout mot de $\Sigma^\star$, \emph{mot binaire normalisé} tout mot binaire qui commence par $1$ ou qui est exactement $0$, et \emph{valeur} d'un mot binaire $u = u_{n-1}\dots u_n$ l'entier $V\p{u} = \sum\limits_{i=0}^{n-1} 2^iu_i$.
    
    \subsection{Lemme de l'étoile}
    
    Soit l'alphabet $\Sigma = \ens{a, b, c}$. Les langages suivants sont-ils réguliers ?
    
    \begin{enumerate}
        \item $L_1 = \ens{a^n \enstq n \equiv 2 \quad \textrm{mod} \ 3}$
        
        \item $L_2 = \ens{a^n \enstq n \in \bdP}$
        
        \item $L_3 = \ens{a^nb^n \enstq n \equiv m \quad \textrm{mod} \ 3}$
        
        \boxansconc{
            On a $L_3 = \p{aaa}^\star\p{ab \vert aabb \vert \epsilon}\p{bbb}^\star$ donc $L_3$ est régulier.
        }
        
        \item $L_4 = $
        
        \item $L_5 = $
        
        \item $L_6 = \ens{u \in \Sigma^\star \enstq u^R = u}$ (ensemble des palindromes).
        
        \boxansconc{
            Soient $n \in \bdN^\star$ et trois lettres $\p{a, b, c} \in \Sigma^3$.
            
            
            \textbf{Bonus :} Ce langage est néanmoins reconnu par une grammaire (non contextuelle) ! En effet, soit $\bcG_\text{pal} = \p{\bcV, \Sigma, \bcR, S}$ la grammaire telle que :
            %
            \begin{enumerate}
                \itt L'alphabet des symboles non terminaux est $\bcV = \ens{S}$
                
                \itt l'alphabet des symboles terminaux est $\Sigma = \ens{a, b, c, \dots}$
                
                \itt Les règles de productions sont $\bcR = \begin{array}[t]{rcl}
                    S &\rightarrow& \epsilon \mid a \mid b \mid c \mid \dots  \\
                    S &\rightarrow& aSa \mid bSb \mid cSc \mid \dots 
                \end{array}$
            \end{enumerate}
            %
            On a bien $L_6 = \bcL\p{\bcG_\text{pal}}$
        }
    \end{enumerate}

    \newpage
    
    \section{Automates}
    
    \subsection{Langages et automates}
    
    On considère les automates suivants :
    
    \begin{center}
        \begin{minipage}{0.48\linewidth}
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                    \node[initial,state,initial text={}] (Q1) {$q_1$};
                    \node[state] (Q3) [below right of=Q1] {$q_3$};
                    \node[state, accepting] (Q2) [above right of=Q3] {$q_2$};

                    \path[->]   (Q1) edge [above] node [align=center]  {$a$} (Q2)
                                (Q3) edge [above, bend left] node [align=center]  {$a$} (Q2)
                                (Q2) edge [below,bend left] node [align=center]  {$a, b$} (Q3)
                                (Q3) edge [below] node [align=center]  {$b$} (Q1)
                                (Q1) edge [loop above] node [align=center]  {$b$} (Q1);
                \end{tikzpicture}
            \end{center}
        \end{minipage}
        %
        \hfill
        %
        \begin{minipage}{0.48\linewidth}
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                    \node[initial,state,accepting,initial text={}] (Q1) {$q_1$};
                    \node[state] (Q2) [right of=Q1] {$q_2$};
                    \node[state, accepting] (Q4) [below of=Q2] {$q_4$};
                    \node[state] (Q3) [left of=Q4] {$q_3$};

                    \path[->]   (Q1) edge [above] node [align=center]  {$b$} (Q2)
                                (Q2) edge [above, bend right] node [align=center]  {$a$} (Q3)
                                (Q3) edge [below,bend right] node [align=center]  {$a$} (Q2)
                                (Q2) edge [right] node [align=center]  {$b$} (Q4)
                                (Q4) edge [below] node [align=center]  {$a$} (Q3)
                                (Q3) edge [left] node [align=center]  {$b$} (Q1)
                                (Q1) edge [loop above] node [align=center]  {$a$} (Q1)
                                (Q4) edge [loop below] node [align=center]  {$b$} (Q4)
                                ;
                \end{tikzpicture}
            \end{center}
        \end{minipage}
        
        \begin{minipage}{0.48\linewidth}
            \begin{center}
                $\bcA_1$
            \end{center}
        \end{minipage}
        %
        \hfill
        %
        \begin{minipage}{0.48\linewidth}
            \begin{center}
                $\bcA_2$
            \end{center}
        \end{minipage}
    \end{center}
    
    Pour $\bcA_1$ et $\bcA_2$, répondre aux questions suivantes :
    %
    \begin{enumerate}
        \item L'automate est-il déterministe ?

        \boxansconc{
            Pour les automates $\bcA_1$ et $\bcA_2$, à chaque état correspond un unique chemin par lettre. Les automates sont donc déterministes.
        }
        
        \item Donner un chemin partant de l'état initial pour le mot $aabb$.
        
        \boxansconc{
            Pour $\bcA_1$, on a :
            %
            \[ q_1 \xrightarrow[]{}\]
        }
        
        \item Le mot $aabb$ est-il accepté par l'automate ?
        
        \item Le mot vide $\epsilon$ est-il accepté par l'automate ?
        
        \item Quel est le langage reconnu par l'automate ?
    \end{enumerate}
    
    \subsection{Déterminisation d'automate}
    
    Déterminiser les automates suivants :
    %
    \begin{center}
        \begin{minipage}{0.48\linewidth}
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                    \node[initial,state,accepting,initial text={}] (Q1) {$1$};
                    \node[state] (Q2) [below of=Q1] {$2$};

                    \path[->]   (Q1) edge [loop right] node [align=center]  {$a$} (Q1)
                                (Q1) edge [right, bend left] node [align=center]  {$a,b$} (Q2)
                                (Q2) edge [left, bend left] node [align=center]  {$b$} (Q1);
                \end{tikzpicture}
            \end{center}
        \end{minipage}
        %
        \hfill
        %
        \begin{minipage}{0.48\linewidth}
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                    \node[initial,state,initial text={}] (Q1) {$1$};
                    \node[state] (Q3) [below right of=Q1] {$3$};
                    \node[state, accepting] (Q2) [above right of=Q3] {$2$};

                    \path[->]   (Q1) edge [below] node [align=center]  {$a$} (Q3)
                                (Q1) edge [above, bend left] node [align=center]  {$\epsilon$} (Q2)
                                (Q2) edge [below,bend left] node [align=center]  {$a$} (Q1)
                                (Q3) edge [below] node [align=center]  {$a,b$} (Q2)
                                (Q3) edge [loop right] node [align=center]  {$b$} (Q3);
                \end{tikzpicture}
            \end{center}
        \end{minipage}
        
        \begin{minipage}{0.48\linewidth}
            \begin{center}
                $\bcA_1$
            \end{center}
        \end{minipage}
        %
        \hfill
        %
        \begin{minipage}{0.48\linewidth}
            \begin{center}
                $\bcA_2$
            \end{center}
        \end{minipage}
    \end{center}
    
    \boxansconc{
        \begin{center}
            \begin{minipage}{0.48\linewidth}
                \begin{center}
                    \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                        \node[initial,state,accepting,initial text={}] (Q1) {$\ens{1}$};
                        \node[state] (Q2) [right of=Q1] {$\ens{2}$};
                        \node[state] (Q3) [below of=Q2] {$\emptyset$};
                        \node[state,accepting] (Q4) [below of=Q1] {$\ens{1, 2}$};
    
                        \path[->]   (Q1) edge [left] node [align=center]  {$a$} (Q4)
                                    (Q1) edge [above, bend left] node [align=center]  {$b$} (Q2)
                                    (Q2) edge [below, bend left] node [align=center]  {$b$} (Q1)
                                    (Q2) edge [right] node [align=center]  {$a$} (Q3)
                                    (Q3) edge [loop below] node [align=center]  {$a,b$} (Q3)
                                    (Q4) edge [loop below] node [align=center]  {$a,b$} (Q4);
                    \end{tikzpicture}
                \end{center}
            \end{minipage}
            %
            \hfill
            %
            \begin{minipage}{0.48\linewidth}
                \begin{center}
                    \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                        \node[state,accepting,initial,initial text={}] (Q4) {$\ens{1,2}$};
                        \node[state,accepting] (Q3) [above of=Q4] {$\ens{2,3}$};
                        \node[state,accepting] (Q2) [above right of=Q3] {$\ens{1,3}$};
                        \node[state] (Q1) [below right of=Q2] {$\ens{1}$};
                        \node[state,accepting] (Q5) [below of=Q2] {$\ens{1,2,3}$};
                        \node[state] (Q6) [below of=Q1] {$\emptyset$};
                        
                        \path[->]   (Q3) edge [left] node [align=center]  {$a$} (Q4)
                                    (Q2) edge [above] node [align=center]  {$b$} (Q3)
                                    (Q1) edge [above] node [align=center]  {$a$} (Q2)
                                    (Q2) edge [left] node [align=center]  {$a$} (Q5)
                                    (Q3) edge [above] node [align=center]  {$b$} (Q5)
                                    (Q4) edge [above] node [align=center]  {$a$} (Q5)
                                    (Q1) edge [right] node [align=center]  {$b$} (Q6)
                                    (Q4) edge [below] node [align=center]  {$b$} (Q6)
                                    (Q5) edge [loop right] node [align=center]  {$a$} (Q5)
                                    (Q6) edge [loop below] node [align=center]  {$a,b$} (Q6)
                                    (Q3) edge [loop above] node [align=center]  {$b$} (Q3);
                    \end{tikzpicture}
                \end{center}
            \end{minipage}
            
            \begin{minipage}{0.48\linewidth}
                \begin{center}
                    Pour $\bcA_1$
                \end{center}
            \end{minipage}
            %
            \hfill
            %
            \begin{minipage}{0.48\linewidth}
                \begin{center}
                    Pour $\bcA_2$
                \end{center}
            \end{minipage}
        \end{center}
    }
    
    \subsection{Automates et expressions régulières}
    
    Pour chacun des automates suivants, donner une expression régulière décrivant le langage reconnu par l'automate.
    
    \subsection{Automate déterministe}
    
    Donner un automate déterministe complet sur $\Sigma = \ens{a, b}$ reconnaissant tous les mots n'ayant pas plus de deux occurrences consécutives de la même lettre.
    
    \boxansconc{
        \begin{center}
            \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                \node[state,accepting,initial,initial text={}] (Q1) {$q_i$};
            \end{tikzpicture}
        \end{center}
    }
    
    \subsection{Automate déterministe}
    
    Soit l'alphabet $\Sigma = \ens{a, b}$.
    
    \begin{enumerate}
        \item Construire un automate déterministe qui accepte les mots ayant un nombre pair de $b$.
        
        \boxansconc{
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                    \node[state,accepting,initial,initial text={}] (Q1) {$q_1$};
                    \node[state] (Q2) [right of=Q1] {$I_b$};
                    
                    \path[->]   (Q1) edge [above, bend left] node [align=center]  {$b$} (Q2)
                                (Q2) edge [below,bend left] node [align=center]  {$b$} (Q1)
                                (Q1) edge [loop above] node [align=center]  {$a$} (Q1)
                                (Q2) edge [loop right] node [align=center]  {$a$} (Q2);
                \end{tikzpicture}
            \end{center}
        }
        
        \item Construire un automate déterministe  qui accepte les mots ayant au plus deux $a$ consécutifs.
        
        \boxansconc{
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                    \node[state,accepting,initial,initial text={}] (Q1) {$q_i$};
                    \node[state] (Q3) [right of=Q1] {$2_a$};
                    \node[state] (Q2) [above of=Q3] {$1_a$};
                    \node[state] (Q4) [right of=Q3] {$q_\bot$};
                    
                    \path[->]   (Q1) edge [above, bend left] node [align=center]  {$a$} (Q2)
                                (Q2) edge [below,bend left] node [align=center]  {$b$} (Q1)
                                (Q2) edge [right] node [align=center]  {$a$} (Q3)
                                (Q3) edge [below] node [align=center]  {$b$} (Q1)
                                (Q3) edge [above] node [align=center]  {$a$} (Q4)
                                (Q1) edge [loop below] node [align=center]  {$a$} (Q1)
                                (Q4) edge [loop above] node [align=center]  {$a,b$} (Q4);
                \end{tikzpicture}
            \end{center}
        }
    \end{enumerate}
    
    \subsection{Divisibilité en binaire}
    
    On considère l'alphabet $\Sigma = \ens{0, 1}$. Pour les trois langages suivants, dire s'il est reconnaissable. Si oui, donner un automate le reconnaissant.
    
    \begin{enumerate}
        \item Le langage $L_2$ des mots binaires représentant un multiple de $2$ (sans zéro non significatif).
        
        \boxansconc{
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=2 cm]
                    \node[state,initial,initial text={}] (QI) {$q_i$};
                    \node[state,accepting] (QF) [right of=QI] {$q_f$};
                    \node[state] (Q1) [below of=QI] {$q_1$};
                    \node[state, accepting] (Q0) [left of=Q1] {$q_0$};
                    
                    \path[->]   (QI) edge [above] node [align=center]  {$0$} (QF)
                                (QI) edge [right] node [align=center]  {$1$} (Q1)
                                (Q1) edge [above, bend right] node [align=center]  {$0$} (Q0)
                                (Q0) edge [below, bend right] node [align=center]  {$1$} (Q1)
                                (Q0) edge [loop above] node [align=center]  {$0$} (Q0)
                                (Q1) edge [loop right] node [align=center]  {$1$} (Q1);
                \end{tikzpicture}
            \end{center}
        }
        
        \item Le langage $L_3$ des mots binaires représentant un multiple de $3$ (sans zéro non significatif).
        
        \boxansconc{
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=2 cm]
                    \node[state,initial,initial text={}] (QI) {$q_i$};
                    \node[state,accepting] (QF) [right of=QI] {$q_f$};
                    \node[state] (Q1) [below of=QI] {$q_1$};
                    \node[state, accepting] (Q0) [left of=Q1] {$q_0$};
                    \node[state] (Q2) [right of=Q1] {$q_2$};
                    
                    \path[->]   (QI) edge [above] node [align=center]  {$0$} (QF)
                                (QI) edge [right] node [align=center]  {$1$} (Q1)
                                (Q1) edge [above, bend right] node [align=center]  {$0$} (Q0)
                                (Q0) edge [below, bend right] node [align=center]  {$1$} (Q1)
                                (Q0) edge [loop above] node [align=center]  {$0$} (Q0)
                                (Q1) edge [loop right] node [align=center]  {$1$} (Q1);
                \end{tikzpicture}
            \end{center}
        }
        
        \item Le langage $L_6$ des mots binaires représentant un multiple de $6$ (sans zéro non significatif).
    \end{enumerate}
    
    \subsection{Ensemble des lettres minuscules}
    
    Soit $\Sigma = \ens{a, b, c, \dots, z}$ l'ensemble des lettres minuscules.
    
    \begin{enumerate}
        \item Donner un automate fini non déterministe acceptant les mots contenant le facteur \guill{cpge}.
        
        \item Déterminer cet automate
    \end{enumerate}
    
    \subsection{} 
    
    Soit l'alphabet $\Sigma = \ens{a, b}$. Pour chacun des langages ci-dessous, donner un automate déterministe le reconnaissant.
    
    \indication{Si l'on arrive pas à donner directement un automate pour le langage, on pourra exprimer le langage comme étant l'intersection de deux langages plus simples, et construire l'automate produit.}
    %
    \begin{enumerate}
        \item $L_1 = \ens{w \in \Sigma^\star \enstq \mod{w}_a \geq 3 \et \mod{w}_b \geq 2}$
        
        \noafter
        %
        \boxans{
            Construisons un automate qui reconnaît \guill{quand il y a trois $a$}, \ie le langage $\ens{w \in \Sigma^\star \enstq \mod{w}_a \geq 3}$:
            µ
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                    \node[state,initial,initial text={}] (Q1) {$a_0$};
                    \node[state] (Q2) [right of=Q1] {$a_1$};
                    \node[state] (Q3) [right of=Q2] {$a_2$};
                    \node[state,accepting] (Q4) [right of=Q3] {$a_3$};
                    
                    \path[->]   (Q1) edge [above] node [align=center]  {$a$} (Q2)
                                (Q2) edge [above] node [align=center] {$a$} (Q3)
                                (Q3) edge [above] node [align=center]  {$a$} (Q4)
                                (Q1) edge [loop above] node [align=center]  {$b$} (Q1)
                                (Q2) edge [loop above] node [align=center]  {$b$} (Q2)
                                (Q3) edge [loop above] node [align=center]  {$b$} (Q3)
                                (Q4) edge [loop right] node [align=center]  {$a,b$} (Q4);
                \end{tikzpicture}
            \end{center}
            %
            Construisons de même un automate qui reconnaît \guill{quand il y a deux $n$}, \ie le langage $\ens{w \in \Sigma^\star \enstq \mod{w}_b \geq 2}$ :
            %
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                    \node[state,initial,initial text={}] (Q1) {$b_0$};
                    \node[state] (Q2) [right of=Q1] {$b_1$};
                    \node[state] (Q3) [right of=Q2] {$b_2$};
                    
                    \path[->]   (Q1) edge [above] node [align=center]  {$b$} (Q2)
                                (Q2) edge [above] node [align=center] {$b$} (Q3)
                                (Q1) edge [loop above] node [align=center]  {$a$} (Q1)
                                (Q2) edge [loop above] node [align=center]  {$a$} (Q2)
                                (Q3) edge [loop right] node [align=center]  {$a,b$} (Q3);
                \end{tikzpicture}
            \end{center}
            %
            Or $L_1 = \ens{w \in \Sigma^\star \enstq \mod{w}_a \geq 3} \cap \ens{w \in \Sigma^\star \enstq \mod{w}_b \geq 2}$, donc on donne l'automate produit, qui reconnaît donc $L_1$ :
        }
        %
        \nobefore\yesafter
        %
        \boxansconc{
            %
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=3 cm]
                    \node[state,initial,initial text={}] (Q1) {$a_0, b_0$};
                    \node[state] (Q2) [right of=Q1] {$a_1,b_0$};
                    \node[state] (Q3) [right of=Q2] {$a_2,b_0$};
                    \node[state] (Q4) [right of=Q3] {$a_3,b_0$};
                    \node[state] (Q5) [below of=Q1] {$a_0,b_1$};
                    \node[state] (Q6) [right of=Q5] {$a_1,b_1$};
                    \node[state] (Q7) [right of=Q6] {$a_2,b_1$};
                    \node[state] (Q8) [right of=Q7] {$a_3,b_1$};
                    \node[state] (Q9) [below of=Q5] {$a_0,b_2$};
                    \node[state] (Q10) [right of=Q9] {$a_1,b_2$};
                    \node[state] (Q11) [right of=Q10] {$a_2,b_2$};
                    \node[state,accepting] (Q12) [right of=Q11] {$a_3,b_2$};
                    
                    \path[->]   (Q1) edge [above] node [align=center]  {$a$} (Q2)
                                (Q2) edge [above] node [align=center] {$a$} (Q3)
                                (Q3) edge [above] node [align=center]  {$a$} (Q4)
                                (Q1) edge [right] node [align=center]  {$b$} (Q5)
                                (Q2) edge [right] node [align=center]  {$b$} (Q6)
                                (Q3) edge [right] node [align=center]  {$b$} (Q7)
                                (Q4) edge [right] node [align=center]  {$b$} (Q8)
                                (Q5) edge [above] node [align=center]  {$a$} (Q6)
                                (Q6) edge [above] node [align=center] {$a$} (Q7)
                                (Q7) edge [above] node [align=center]  {$a$} (Q8)
                                (Q5) edge [right] node [align=center]  {$b$} (Q9)
                                (Q6) edge [right] node [align=center]  {$b$} (Q10)
                                (Q7) edge [right] node [align=center]  {$b$} (Q11)
                                (Q8) edge [right] node [align=center]  {$b$} (Q12)
                                (Q9) edge [above] node [align=center]  {$a$} (Q10)
                                (Q10) edge [above] node [align=center] {$a$} (Q11)
                                (Q11) edge [above] node [align=center]  {$a$} (Q12);
                \end{tikzpicture}
            \end{center}
        }
        %
        \yesbefore
        
        \item 
        
        \item
        
        \item $L_4 = \ens{w \in \Sigma^\star \enstq \mod{w}_a \equiv 0 \quad \intc{2} \et \text{chaque $a$ est suivi par au moins un $b$}}$.
    \end{enumerate}
    
    \subsection{}
    
    \subsection{Thompson et Glushkov}
    
    Soit l'alphabet $\Sigma = \ens{a, b, c}$, et l'expression $e = \p{a \vert c}^\star abb\p{a\vert c}^\star$.
    
    \begin{enumerate}
        \item Construire l’automate de \textsc{Thompson} associé à $e$.
        
        \boxansconc{
            \begin{center}
                \begin{tikzpicture}[>=Latex,auto,node distance=2 cm]
                    \node[state,initial,initial text={}] (QI) {$q_i$};
                    \node[state] (Q0) [right of=QI] {$q_0$};
                    \node[state] (Q1) [above right of=Q0] {$q_1$};
                    \node[state] (Q2) [right of=Q1] {$q_2$};
                    \node[state] (Q3) [below right of=Q0] {$q_3$};
                    \node[state] (Q4) [right of=Q3] {$q_4$};
                    \node[state] (Q5) [below right of=Q2] {$q_5$};
                    \node[state] (Q6) [right of=Q5] {$q_6$};
                    
                    \path[->]   (QI) edge [above] node [align=center]  {$\epsilon$} (Q0)
                                (Q0) edge [above] node [align=center]  {$\epsilon$} (Q1)
                                (Q1) edge [above] node [align=center]  {$a$} (Q2)
                                (Q2) edge [above] node [align=center]  {$\epsilon$} (Q5)
                                (Q5) edge [above] node [align=center]  {$\epsilon$} (Q6)
                                (Q0) edge [below] node [align=center]  {$\epsilon$} (Q3)
                                (Q3) edge [below] node [align=center]  {$b$} (Q4)
                                (Q4) edge [below] node [align=center]  {$\epsilon$} (Q5)
                                (Q0) edge [above, bend left] node [align=center]  {$\epsilon$} (Q5)
                                (Q5) edge [above, bend left] node [align=center]  {$\epsilon$} (Q0);
                \end{tikzpicture}
            \end{center}
        }
    \end{enumerate}
\end{document}
